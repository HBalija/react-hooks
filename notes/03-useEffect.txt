useEffect

- manages side effects like fetching data from http
- we can have multiple useEffect calls

- gets executed after every component render cycle
- important: for every render cycle it gets executed (after it)

takes a function as an argument

  useEffect(() => {
    axios.get('http://localhost:8000/ingredients/')
      .then(res => {
        setIngs(res.data);
      });
  });

  --> used like this, it acts like componentDidUpdate (it rerenders)

------------------------------------------------------------------------------------

  - ADDING SECOND ARGUMENT TO USE EFFECt: dependency list


  ---------------------------------------------------------------------------------------

- if we add [] as a second argument, it will act as componendDidMount: will not trigger rerender
- will run only once


  useEffect(() => {
    axios.get('http://localhost:8000/ingredients/')
      .then(res => {
        setIngs(res.data);
      });
  }, []);


USE EFFECT DEPENDENCIES

  useEffect(() => {
    console.log('RENDERING INGREDIENTS', ings); // eslint-disable-line no-console

    // this will run only if ings change
  }, [ings]);

- we can also destruct props to use specific prop in dependency array



const {someProp, otherProp} = props

  useEffect(() => {
    console.log('RENDERING INGREDIENTS', ings); // eslint-disable-line no-console

    // this will run only if ings change
  }, [someProp]);



CLEANING UP USE EFFECT

- starting code:

  useEffect(() => {
    setTimeout(() => {
      if (titleFilter === inputRef.current.value) {
        axios.get(url)
          .then(res => {
            onLoadIngredients(res.data);
          });
      }
    }, 500);
  }, [titleFilter, onLoadIngredients, inputRef]);


  - problem: we set new timers on every keystroke without clearing previous ones

- setTimeout() returns a reference to the function

useEffect can return a function wich will act like componentWillUnmount

- that function will run before body in useEffect
--> cleanup will run for previous effect before new effect is applied


--> new code with cleanup in place
--> WE NEED TO RETURN A FUNCTION DEFINITION!!!

  useEffect(() => {

    const timer = setTimeout(() => {
      if (titleFilter === inputRef.current.value) {
        axios.get(url)
          .then(res => {
            onLoadIngredients(res.data);
          });
      }
    }, 500);

    return () => {
      clearTimeout(timer);
    };

  }, [titleFilter, onLoadIngredients, inputRef]);


WHEN TO USE:

- when we make new stuff in useEffect
