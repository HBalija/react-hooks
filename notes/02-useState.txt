- allows us to manage state in functional components

useState() - takes a default value (can be any value)

- it returns an array with 2 items

with array destructuring we get two variables: value, and dispatch function that changes the state

useState({title: '', amount: ''})


  const inputState = useState({ title: '', amount: '' });

then use:

    <input
      type="text"
      id="title"
      value={inputState[0].title}
      onChange={event => inputState[1]({ title: event.target.value, amount: inputState[0].amount })}/>


- the problem here is if we have an object, we need to pass the whole object
(unlike setState() in CBC)
- we write a lot of ugly code and we are not sure that the whole state object
will be updated in more complex apps
--> we can pass a function when setting state (like in CBC) and we get prevInputState arg

onChange={event => inputState[1]((prevInputState) => (
  { title: event.target.value, amount: prevInputState.amount }
  ))}

- also ugly, and we break code because we use closure where we are reusing event object and get error

- we can create a const  where we store event object and use that value in dispatch function

onChange={event => {
  const newTitle = event.target.value;
  inputState[1](prevInputState => ({ title: newTitle, amount: prevInputState.amount } ))}}


REFACTORING:

- we can destructure array

const [inputState, setInputState] = useState({ title: '', amount: '' });

--> now we can use this values:

value={inputState.title}

onChange={event => {
  const newTitle = event.target.value;
  setInputState(prevInputState => ({ title: newTitle, amount: prevInputState.amount }))}}


--> if we had multiple attributes in object, could get ugly --> SOLUTION: use multiple useState()


  const [title, setTitle] = useState('');
  const [amount, setAmount] = useState('');

<input type="text" id="title" value={title} onChange={event => setTitle(event.target.value)} />

<input type="number" id="amount" value={amount} onChange={event => setAmount(event.target.value)} />
